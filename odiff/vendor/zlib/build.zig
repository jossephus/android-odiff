const std = @import("std");

const DEFAULT_NDK_PATH = "/nix/store/lnvzilffxf3wb6dg6fsgg12aacpip3ch-android-sdk-env/share/android-sdk/ndk/29.0.13113456/toolchains/llvm/prebuilt/linux-x86_64/sysroot/"; // Based on the current flake.nix and flake.locks
const DEFAULT_NDK_VERSION = "29.0.13113456";
const DEFAULT_ANDROID_API_VERSION: u32 = 34;

// arm64-v8a: zig build -Dtarget=aarch64-linux-android.34
// armeabi-v7a: zig build -Dtarget=arm-linux-androideabi.34
// x86: zig build -Dtarget=x86-linux-android.34  (not i686)
// x86_64: zig build -Dtarget=x86_64-linux-android.34

const build_targets: []const std.Target.Query = &.{
    .{ .cpu_arch = .aarch64, .os_tag = .linux, .abi = .android, .android_api_level = 34 },
    .{ .cpu_arch = .arm, .os_tag = .linux, .abi = .androideabi, .android_api_level = 34 },
    .{ .cpu_arch = .x86, .os_tag = .linux, .abi = .android, .android_api_level = 34 },
    .{ .cpu_arch = .x86_64, .os_tag = .linux, .abi = .android, .android_api_level = 34 },
};

pub fn build(b: *std.Build) !void {
    const upstream = b.dependency("zlib", .{});

    const optimize = b.standardOptimizeOption(.{});
    const target = b.standardTargetOptions(.{});
    //_ = t;

    const ndk_path = b.option([]const u8, "ndk-path", "Path to Android NDK sysroot") orelse DEFAULT_NDK_PATH;
    const ndk_version = b.option([]const u8, "ndk-version", "Android NDK version") orelse DEFAULT_NDK_VERSION;
    const android_api_version = b.option(u32, "android-api", "Android API level") orelse DEFAULT_ANDROID_API_VERSION;

    //for (build_targets) |target_query| {
    //const target = b.resolveTargetQuery(target_query);
    const abi_output_dir = getOutputDir(target.result) catch |err| {
        std.log.err("Unsupported target architecture: {}", .{target.result.cpu.arch});
        return err;
    };
    const header_output_dir = try std.fs.path.join(b.allocator, &.{ abi_output_dir, "include" });

    const lib = b.addLibrary(.{
        .name = "z",
        .linkage = .static,
        .root_module = b.createModule(.{
            .target = target,
            .optimize = optimize,
            .link_libc = true,
        }),
    });

    lib.linkLibC();

    const android_triple = getAndroidTriple(lib.rootModuleTarget()) catch |err| @panic(@errorName(err));

    const libc_config = createLibC(b, android_triple, android_api_version, ndk_path, ndk_version);

    lib.setLibCFile(libc_config);

    lib.addCSourceFiles(.{
        .root = upstream.path(""),
        .files = &.{
            "adler32.c",
            "crc32.c",
            "deflate.c",
            "infback.c",
            "inffast.c",
            "inflate.c",
            "inftrees.c",
            "trees.c",
            "zutil.c",
            "compress.c",
            "uncompr.c",
            "gzclose.c",
            "gzlib.c",
            "gzread.c",
            "gzwrite.c",
        },
        .flags = &.{
            "-DHAVE_SYS_TYPES_H",
            "-DHAVE_STDINT_H",
            "-DHAVE_STDDEF_H",
            "-DZ_HAVE_UNISTD_H",
        },
    });
    lib.installHeadersDirectory(upstream.path(""), "", .{
        .include_extensions = &.{
            "zconf.h",
            "zlib.h",
        },
    });

    const install_artifact = b.addInstallArtifact(lib, .{
        .h_dir = .{
            .override = .{
                .custom = header_output_dir,
            },
        },
        .dest_dir = .{
            .override = .{
                .custom = abi_output_dir,
            },
        },
    });

    b.getInstallStep().dependOn(&install_artifact.step);
    //}
}

// Convert Zig target to Android NDK triple format
fn getAndroidTriple(target: std.Target) error{InvalidAndroidTarget}![]const u8 {
    if (target.abi != .android and target.abi != .androideabi) return error.InvalidAndroidTarget;
    return switch (target.cpu.arch) {
        .x86 => "i686-linux-android",
        .x86_64 => "x86_64-linux-android",
        .arm => "arm-linux-androideabi",
        .aarch64 => "aarch64-linux-android",
        .riscv64 => "riscv64-linux-android",
        else => error.InvalidAndroidTarget,
    };
}

// Get Android ABI output directory name from target architecture
fn getOutputDir(target: std.Target) ![]const u8 {
    return switch (target.cpu.arch) {
        .aarch64 => "arm64-v8a",
        .arm => "armeabi-v7a",
        .x86 => "x86",
        .x86_64 => "x86_64",
        .riscv64 => "riscv64",
        else => error.UnsupportedArchitecture,
    };
}

// Create Android libc configuration file for Zig
fn createLibC(b: *std.Build, system_target: []const u8, android_api_version: u32, ndk_sysroot_path: []const u8, ndk_version: []const u8) std.Build.LazyPath {
    const libc_file_format =
        \\# Generated by zig-android-sdk. DO NOT EDIT.
        \\
        \\# The directory that contains `stdlib.h`.
        \\# On POSIX-like systems, include directories be found with: `cc -E -Wp,-v -xc /dev/null`
        \\include_dir={[include_dir]s}
        \\
        \\# The system-specific include directory. May be the same as `include_dir`.
        \\# On Windows it's the directory that includes `vcruntime.h`.
        \\# On POSIX it's the directory that includes `sys/errno.h`.
        \\sys_include_dir={[sys_include_dir]s}
        \\
        \\# The directory that contains `crt1.o`.
        \\# On POSIX, can be found with `cc -print-file-name=crt1.o`.
        \\# Not needed when targeting MacOS.
        \\crt_dir={[crt_dir]s}
        \\
        \\# The directory that contains `vcruntime.lib`.
        \\# Only needed when targeting MSVC on Windows.
        \\msvc_lib_dir=
        \\
        \\# The directory that contains `kernel32.lib`.
        \\# Only needed when targeting MSVC on Windows.
        \\kernel32_lib_dir=
        \\
        \\gcc_dir=
    ;

    const include_dir = b.fmt("{s}/usr/include", .{ndk_sysroot_path});
    const sys_include_dir = b.fmt("{s}/usr/include/{s}", .{ ndk_sysroot_path, system_target });
    const crt_dir = b.fmt("{s}/usr/lib/{s}/{d}", .{ ndk_sysroot_path, system_target, android_api_version });

    const libc_file_contents = b.fmt(libc_file_format, .{
        .include_dir = include_dir,
        .sys_include_dir = sys_include_dir,
        .crt_dir = crt_dir,
    });

    const filename = b.fmt("android-libc_target-{s}_version-{d}_ndk-{s}.conf", .{ system_target, android_api_version, if (ndk_version.len > 0) ndk_version else "unknown" });

    const write_file = b.addWriteFiles();
    const android_libc_path = write_file.add(filename, libc_file_contents);
    return android_libc_path;
}
